<html>
<head>
    <title>Puck.js MARG/IMU heading project</title>
</head>
<body style="margin:0px">
    <script src="https://www.puck-js.com/puck.js"></script>
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>
    <button id="btnCalibrtr">Calibrate</button><br>
    <span>Battery level: <span id="battLevelSpan"></span></span><br>
    <span>other data: <span id="otherData"></span></span><br>
    <span>good magnet: <span id="goodMagnet"></span></span><br>
    <span>Algorithm: <span id="algorithm"></span></span><br>
    <span>Calibrating: <span id="caliCounter"></span></span>
    <table>
      <tr>
        <td> </td>
        <td> Gyroscope </td>
        <td> Accelerometer </td>
        <td> Magnetometer </td>
        <td> Calibrated Mag </td>
      </tr>
      <tr>
        <td> X </td>
        <td> <span id="tdGyroX">      </span> </td>
        <td> <span id="tdAccelX">     </span> </td>
        <td> <span id="tdMagX">       </span> </td>
        <td> <span id="tdCalibMagX">  </span> </td>
      </tr>
      <tr>
        <td> Y </td>
        <td> <span id="tdGyroY">      </span> </td>
        <td> <span id="tdAccelY">     </span> </td>
        <td> <span id="tdMagY">       </span> </td>
        <td> <span id="tdCalibMagY">  </span> </td>
      </tr>
      <tr>
        <td> Z </td>
        <td> <span id="tdGyroZ">      </span> </td>
        <td> <span id="tdAccelZ">     </span> </td>
        <td> <span id="tdMagZ">       </span> </td>
        <td> <span id="tdCalibMagZ">  </span> </td>
      </tr>
      <tr>
        <td> abs </td>
        <td> <span id="tdGyroABS">      </span> </td>
        <td> <span id="tdAccelABS">     </span> </td>
        <td> <span id="tdMagABS">       </span> </td>
        <td> <span id="tdCalibMagABS">  </span> </td>
      </tr>
    </table>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="./madgwick.js"></script>
    <script src="./calibrtr.js"></script>
    <script>

// Constants (revise these?)
// max 16g at 32768
const accel_factor = 9.8 * 16 / 32768;
// max 2000dps at 32768, and a calibration factor
const gyro_factor = (1/0.87) * 1000 / 32768 * 2*Math.PI / 360;
//  const gyro_factor = 1000 / 32768 * 2*Math.PI / 360;
// don't change hz without revising the two above factors
const hz = 104;              // Data rate of accel/gyro.
const magHz = 80;           // Data rate of magnetometer.
const deltat = 1/hz;        // Change in time
const battLevelSpan = document.getElementById('battLevelSpan');
const otherData = document.getElementById('otherData');
const algorithm = document.getElementById('algorithm');
const goodMagnet = document.getElementById('goodMagnet');
const caliCounter = document.getElementById('caliCounter');

// Code to upload to Puck.js
var PUCK_CODE = `
freq = ${hz}
// Blink green LED to show we've connected
digitalPulse(LED2, 1, 500);

// Turn on accel/gyro, then specify parameters
// see acc_factor and gyro_factor
Puck.accelOn();
Puck.accelWr(0x10, 0b01000100);
Puck.accelWr(0x11, 0b01001000);
// Turn on magnetometer
Puck.magOn(${magHz});

// Report the battery every 10 seconds
const batteryIntervalId = setInterval(function(){
    reportBattery()
}, 10000);
    
// Turn off the accelerometer and battery reporting when we disconnect. Blink red LED.
NRF.on('disconnect', function() {
    stop_running();
    digitalPulse(LED1, 1, 500);
    clearInterval(batteryIntervalId);
});

// Have Puck report battery every 30 seconds
function reportBattery(){
    var d = [
        "B",
        Math.round(Puck.getBatteryPercentage())
      ];
    Bluetooth.println(d.join(","));
}
// When we get accelerometer/gyro data, report accel/gyro/mag data
// they are just reported directly from the sensor,
// scaling and calibration is done later
Puck.on('accel',function(a) {
    mag = Puck.mag();
    var d = [
        "A",
        Math.round(a.acc.x),
        Math.round(a.acc.y),
        Math.round(a.acc.z),
        Math.round(a.gyro.x),
        Math.round(a.gyro.y),
        Math.round(a.gyro.z),
        Math.round(mag.x),
        Math.round(mag.y),
        Math.round(mag.z)
    ];
    Bluetooth.println(d.join(","));
        });
        `;

// Vector3 variables to hold data from accel/gyro/mag/battery
var accel = new THREE.Vector3( 0, 0, 0);
var accel_rot = new THREE.Vector3( 0, 0, 0);
var gyro = new THREE.Vector3(0, 0, 0);
var mag = new THREE.Vector3(0, 0, 0);
var mag_cali = new THREE.Vector3(0, 0, 0);
var mag_cali_rot = new THREE.Vector3(0, 0, 0);
var mag_orto = new THREE.Vector3(0, 0, 0);
var linearAccel = new THREE.Vector3(0, 0, 0);
var velocity = new THREE.Vector3(0, 0, 0);
var position = new THREE.Vector3(0, 0, 0);
var battery = 100;

// Quaternion to hold rotation data
var rotation = new THREE.Quaternion(0, 0, 0, 1);

// For holding calibration data
var magneto_data = [];
var calibrating = false;
var calibrating_counter;
var cd = {
    matrix: [ [ 0.572, -0.077, -0.138],
              [-0.077,  0.670, -0.077],
              [-0.138, -0.077,  0.399]],
    transl: [667, -214, -924],
    radius: 178
};

var mag_matrix = new THREE.Matrix3();
var mag_transl = new THREE.Vector3();
var mag_radius;
var mag_radius_sq;
function calibrate(data) {
    mag_matrix.set(data.matrix[0][0],
                   data.matrix[0][1],
                   data.matrix[0][2],
                   data.matrix[0][0],
                   data.matrix[1][1],
                   data.matrix[1][2],
                   data.matrix[2][0],
                   data.matrix[2][1],
                   data.matrix[2][2]);
    mag_transl.x = data.transl[0];
    mag_transl.y = data.transl[1];
    mag_transl.z = data.transl[2];
    mag_radius   = data.radius;
    mag_radius_sq = mag_radius * mag_radius;
}
calibrate(cd);
caliCounter.innerText = JSON.stringify(cd);


// data for the Madgwick algorithm
frame = {
    iteration: 0,
    deltat: deltat,
    SEq_1: 1,
    SEq_2: 0,
    SEq_3: 0,
    SEq_4: 0,
    acc_x: 0,
    acc_y: 0,
    acc_z: 0,
    vel_x: 0,
    vel_y: 0,
    vel_z: 0,
    pos_x: 0,
    pos_y: 0,
    pos_z: 0,
    b_x: 1,
    b_z: 0,
    w_bx: 0,
    w_by: 0,
    w_bz: 0,
    beta: 1*Math.sqrt(3.0 / 4.0),
    zeta: 1*Math.sqrt(3.0 / 4.0),
    //beta: 0,
    //zeta: 0,
    still: 0,
    stillness: 20
};




// When we click the connect button...
var connection;
document.getElementById("btnDisconnect").addEventListener("click", function() 
{
    // disconnect if connected already
    if (connection) {
        connection.close();
            connection = undefined;
    }
});

document.getElementById("btnConnect").addEventListener("click", function() 
{
    // disconnect if connected already
    if (connection) {
        connection.close();
        connection = undefined;
    }
    // Connect
    Puck.connect(function(c) {
        if (!c) {
            alert("Couldn't connect!");
            return;
        }
        connection = c;
        // Handle the data we get back, and call 'onLine'
        // whenever we get a line
        var buf = "";
        connection.on("data", function(d) {
        buf += d;
        var l = buf.split("\n");
        buf = l.pop();
            l.forEach(onLine);
        });
        // First, reset the Puck
        connection.write("reset();\n", function() {
                // Wait for it to reset itself
            setTimeout(function() {
                // Now upload our code to it
                connection.write("\x03\x10if(1){"+PUCK_CODE+"}\n",
                function() { console.log("Ready..."); });
            }, 1500);
        });
    });
});

// magnetocalibration:
document.getElementById("btnCalibrtr").addEventListener("click", function() 
{
    calibrating = true;
});

// When we get a line of data, check it and if it's
// from the accelerometer, update it
function onLine(line) 
{
    //console.log("RECEIVED:"+line);
    var d = line.split(",");

    // Battery data
    if (d.length==2 && d[0]=="B") 
    {
        battery = parseInt(d[1]);  
        battLevelSpan.innerText = battery + "%";
        //console.log("BATTERY");
        //console.log(battery);
    }
    else if (d.length==10 && d[0]=="A") 
    {
        // Accelerometer
        accel.x = (parseInt(d[1])) * accel_factor;
        accel.y = (parseInt(d[2])) * accel_factor;
        accel.z = (parseInt(d[3])) * accel_factor;
        document.getElementById('tdAccelX').innerText = accel.x.toFixed(4);
        document.getElementById('tdAccelY').innerText = accel.y.toFixed(4);
        document.getElementById('tdAccelZ').innerText = accel.z.toFixed(4);
        document.getElementById('tdAccelABS').innerText
            = accel.length().toFixed(4);

        // Gyroscope
        gyro.x = parseInt(d[4]) * gyro_factor;
        gyro.y = parseInt(d[5]) * gyro_factor;
        gyro.z = parseInt(d[6]) * gyro_factor;
        document.getElementById('tdGyroX').innerText = gyro.x.toFixed(4);
        document.getElementById('tdGyroY').innerText = gyro.y.toFixed(4);
        document.getElementById('tdGyroZ').innerText = gyro.z.toFixed(4);
        document.getElementById('tdGyroABS').innerText
            = gyro.length().toFixed(4);

        // Magnetometer
        mag.x = parseInt(d[7]);
        mag.y = parseInt(d[8]);
        mag.z = parseInt(d[9]);
        document.getElementById('tdMagX').innerText = mag.x;
        document.getElementById('tdMagY').innerText = mag.y;
        document.getElementById('tdMagZ').innerText = mag.z;
        document.getElementById('tdMagABS').innerText
            = mag.length().toFixed(0);

        // Calibrated magnetometer
        mag_cali.x = mag.x;
        mag_cali.y = mag.y;
        mag_cali.z = mag.z;
        mag_cali.addScaledVector(mag_transl, -1);
        mag_cali.applyMatrix3(mag_matrix);
        document.getElementById('tdCalibMagX').innerText
            = mag_cali.x.toFixed(0);
        document.getElementById('tdCalibMagY').innerText
            = mag_cali.y.toFixed(0);
        document.getElementById('tdCalibMagZ').innerText
            = mag_cali.z.toFixed(0);
        document.getElementById('tdCalibMagABS').innerText
            = mag_cali.length().toFixed(0);

        // Magnetometer reding ortogonal to accel
        mag_orto.x = mag_cali_rot.x;
        mag_orto.y = mag_cali_rot.y;
        mag_orto.z = mag_cali_rot.z;
        mag_orto.addScaledVector(accel,
            - mag_cali_rot.dot(accel)
            / accel.lengthSq())

        // Update the Madgwick filter
        s = {
            w_x: gyro.x,
            w_y: gyro.y,
            w_z: gyro.z,
            a_x: accel.x,
            a_y: accel.y,
            a_z: accel.z,
            m_x: mag_cali.x,
            m_y: mag_cali.y,
            m_z: mag_cali.z
        };
        let mag_norm_sq = mag_cali.x*mag_cali.x
                        + mag_cali.y*mag_cali.y
                        + mag_cali.z*mag_cali.z;
        if(0.75*mag_radius_sq < mag_norm_sq
               && mag_norm_sq < 1.5*mag_radius_sq)
        {
            update_MARG(s,frame);
            algorithm.innerText = "MARG";
        } else {
            update_IMU(s,frame);
            algorithm.innerText = "IMU";
        }

        // Rotation 
        rotation.x = frame.SEq_2;
        rotation.y = frame.SEq_3;
        rotation.z = frame.SEq_4;
        rotation.w = frame.SEq_1;

        // Rotaded calibrated magnetometer
        mag_cali_rot.x = mag_cali.x;
        mag_cali_rot.y = mag_cali.y;
        mag_cali_rot.z = mag_cali.z;
        mag_cali_rot.applyQuaternion(rotation);

        // Rotated acceleration
        accel_rot.x = accel.x;
        accel_rot.y = accel.y;
        accel_rot.z = accel.z;
        accel_rot.applyQuaternion(rotation);

        render();

        goodMagnet.innerText = "<br>\n" + mag.x
                             + "<br>\n" + mag.y
                             + "<br>\n" + mag.z;
        

//          calibrating
//          + " "
//          + calibrating_counter
//          + parseInt(mag_radius);

        calibrate(cd);
//        caliCounter.innerText = magneto_data;
        if(calibrating) {
            if(calibrating_counter < 1500) {
                caliCounter.innerText = "Collecting data: " + calibrating_counter;
                if( Math.abs(mag.x) < 1000
                 && Math.abs(mag.y) < 1000
                 && Math.abs(mag.z+2000) < 1000 ) {
                    magneto_data.push([mag.x, mag.y, mag.z]);
                    calibrating_counter++;
                }
                if(calibrating_counter%20 == 0) {
                    digitalPulse(LED3, 1, 100);
                }
            } else {
                calibrating = false;
                calibrating_counter = 0;
                cd.radius = 0;
                cd = fit_to_ellipsoid_bla(magneto_data);
                caliCounter.innerText = JSON.stringify(cd);
                magneto_data = [];
                // magnetocalibration:
                
            }
        }
    }
}

function fit_to_ellipsoid_bla(R) {
  m = R.length;
  console.log("R.length = " + R.length);
  mat = [];
  col = [];
  R.forEach( (e) => {
    mat.push([
      e[0]*e[0]-e[2]*e[2],
      e[1]*e[1]-e[2]*e[2],
      2*e[0]*e[1],
      2*e[1]*e[2],
      2*e[0]*e[2],
      -2*e[0],
      -2*e[1],
      -2*e[2],
      1]);
    col.push( -e[2]*e[2] );
  });
  s = pinv(mat,col);
  console.log(s);
  B = [ [ s[0], s[2], s[4]          ],
        [ s[2], s[1], s[3]          ],
        [ s[4], s[3], 1-s[0]-s[1] ] ];
  A = mat_sym_3x3_sqrt(B);
  v = [];
//  for(f=0; f<3; f++) {
//    w = pinv(B, [s[5], s[6], s[7]]);
//    console.log("w = ");
//    console.log(w);
//    v.push( w[0]*s[5] + w[1]*s[6] + w[2]*s[7] )
//  }
  w = pinv(B,[1,0,0]);
  v.push( w[0]*s[5] + w[1]*s[6] + w[2]*s[7] );
  w = pinv(B,[0,1,0]);
  v.push( w[0]*s[5] + w[1]*s[6] + w[2]*s[7] );
  w = pinv(B,[0,0,1]);
  v.push( w[0]*s[5] + w[1]*s[6] + w[2]*s[7] );
  vtBv = 0;
  for(i=0; i<3; i++) {
    for(j=0; j<3; j++) {
      vtBv += v[i] * B[i][j] * v[j];
    }
  }

  R = Math.sqrt(vtBv - s[8]);
  s = {
    transl: v,
    matrix: A,
    radius: R,
    eigenv: eigenvals_3x3_sym(B),
  };
  return(s);
}

// WebGL boilerplate
var scene, camera, renderer, cylinder, xdir, ydir, zdir;
var WIDTH  = window.innerWidth;
var HEIGHT = window.innerHeight;

// Graphics initialization
function init() 
{
    // Three.js has a default up y axis.
    // Set this to z instead to align with the Puck.
    THREE.Object3D.DefaultUp.set(0.0, 0.0, 1.0);
    scene = new THREE.Scene();

    // Set up camera
    camera = new THREE.PerspectiveCamera(100, WIDTH / HEIGHT, 0.1, 200);
    camera.position.set(10, 10, 5);
    camera.lookAt(scene.position);

    // Illumination
    var llum = new THREE.DirectionalLight();
    llum.intensity=30;
    llum.position.x=camera.position.x;
    llum.position.y=camera.position.y;
    llum.position.z=camera.position.z;
    llum.lookAt(scene.position);
    scene.add(llum);

    // Create a puck model with xyz axes using cylinders
    const geometry = new THREE.CylinderGeometry(5, 5, 1, 32);
    const material = new THREE.MeshStandardMaterial({ color: 0x000000 });
    geometry.rotateX(degrees_to_radians(90));
    cylinder = new THREE.Mesh(geometry, material);
    
    // x axis (blue)
    xdir = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5, 8),
                          new THREE.MeshStandardMaterial({ color: 0x0000ff }));
    xdir.translateX(5);
    xdir.rotateZ(degrees_to_radians(90));

    // y axis (red)
    ydir = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5, 8),
                          new THREE.MeshStandardMaterial({ color: 0xff0000 }));
    ydir.translateY(5);
    
    // z axis (green)
    zdir = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5, 8),
                          new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
    zdir.translateZ(2.5);
    zdir.rotateX(degrees_to_radians(90));
    
    // acceleration
    accdir = new THREE.Mesh(new THREE.SphereGeometry(2, 10, 10),
                        new THREE.MeshStandardMaterial({ color: 0x00aaaa }));
    acc_rotdir = new THREE.Mesh(new THREE.SphereGeometry(2, 10, 10),
                 new THREE.MeshStandardMaterial({ color: 0x000000 }));
    
    // magnet
    magdir = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10),
                       new THREE.MeshStandardMaterial({ color: 0x555500 }));
    mag_calidir = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10),
            new THREE.MeshStandardMaterial({ color: 0xff0000 }));
    mag_cali_rotdir = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10),
            new THREE.MeshStandardMaterial({ color: 0xffffff }));
    mag_ortodir = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10),
             new THREE.MeshStandardMaterial({ color: 0x2233ff }));
    
    // Add axes as children of the cylinder
    cylinder.add(xdir);
    cylinder.add(ydir);
    cylinder.add(zdir);

    // Add the cylinder to the scene
    scene.add(cylinder);
    //scene.add(accdir);
    scene.add(acc_rotdir);
    //scene.add(magdir);
    scene.add(mag_calidir);
    scene.add(mag_cali_rotdir);
    //scene.add(mag_ortodir);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(WIDTH, HEIGHT);

    document.body.appendChild(renderer.domElement);
}

// Converts degrees to radians
function degrees_to_radians(degrees)
{
    // Store the value of pi.
    var pi = Math.PI;
    // Multiply degrees by pi divided by 180 to convert to radians.
    return degrees * (pi/180);
}

 
// Renders cylinder with rotation from Puck (if connected)
function render() 
{
    // Set rotation based on quaternion
    cylinder.setRotationFromQuaternion(rotation);
    // translate accdir
    accdir.position.x = accel.x;
    accdir.position.y = accel.y;
    accdir.position.z = accel.z;
    acc_rotdir.position.x = accel_rot.x;
    acc_rotdir.position.y = accel_rot.y;
    acc_rotdir.position.z = accel_rot.z;
    magdir.position.x = mag.x / 20;
    magdir.position.y = mag.y / 20;
    magdir.position.z = mag.z / 20;
    mag_calidir.position.x = mag_cali.x / 30;
    mag_calidir.position.y = mag_cali.y / 30;
    mag_calidir.position.z = mag_cali.z / 30;
    mag_cali_rotdir.position.x = mag_cali_rot.x / 10;
    mag_cali_rotdir.position.y = mag_cali_rot.y / 10;
    mag_cali_rotdir.position.z = mag_cali_rot.z / 10;
    mag_ortodir.position.x = mag_orto.x / 20;
    mag_ortodir.position.y = mag_orto.y / 20;
    mag_ortodir.position.z = mag_orto.z / 20;
    renderer.render(scene, camera);
}

init();
render();

</script>
    </body>
</html>
